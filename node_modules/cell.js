var events = require("events");

function Cell(kind) {
    // by default we are a cooperative cell
    if (kind == undefined) kind = "coop";

    // sequential identifier, unique to each cell
    // in the population
    this.id    = this.seq();
    // typically "coop" or "cheat"
    this.kind  = kind;
    // time when this cell was born
    this.birth = new Date().getTime();
    // is this cell currently alive?
    this.alive = true;
    // where is this cell?
    this.x     = 0;
    this.y     = 0;

    // the food or public good. it is a dictionary 
    // mapping sources of food (other cells) to another
    // dictionary,
    //
    // { amount: n, time: t }
    //
    // describing the amount of food and when it was
    // received.
    this.food  = {};

    this.start_timers();
    events.EventEmitter.call(this);
}

Cell.prototype = Object.create(events.EventEmitter.prototype);
Cell.prototype.constructor = Cell;

/**
 * Cells have a unique identifier or sequence 
 * number in a population. This is the machinery
 * which provides it.
 **/
Cell.prototype._seq = 0;
Cell.prototype.seq = function () {
    return Cell.prototype._seq++;
}

/**
 * Reset the sequence number, this is a static 
 * class method called when a simulation is
 * restarted.
 **/
Cell.prototype.reset = function () {
    Cell.prototype._seq = 0;
}

/**
 * Return statistics about the neighbourhood
 * and nutrition, fitness and so forth.
 **/ 
Cell.prototype.stats = function () {
    var stats = {
	neighbours:  0,
	cooperators: 0,
	food:        0,
	age:         new Date().getTime() - this.birth
    }
    for (var i in this.food) {
	stats.neighbours += 1;
	if (this.food[i].amount > 0) {
	    stats.cooperators += 1;
	    stats.food += this.food[i].amount;
	}
    }
    return stats;
}

/**
 * Parameters relating to cost, benefit, payoff and so forth
 **/
Cell.prototype.sigma = function () { return -30; }
Cell.prototype.cost  = function () { return 1; }
Cell.prototype.bias  = function () { return 0.1; }

/**
 * The benefit, payoff and fitness game-theory functions.
 **/
Cell.prototype.benefit = function(stats) {
    if (stats == undefined) stats = this.stats();
    return 1 / (1 + Math.exp(this.sigma() * (stats.cooperators/stats.neighbours - 1/2)));
}

Cell.prototype.payoff = function (stats) {
    if (stats == undefined) stats = this.stats();
    if (this.kind == "coop") {
	return this.benefit(stats) * this.cost() * stats.cooperators/stats.neighbours 
	    - this.cost();
    } else {
	return this.benefit(stats) * this.cost() * stats.cooperators/stats.neighbours;
    }
}

Cell.prototype.fitness = function(stats) {
    if (stats == undefined) stats = this.stats();
    return Math.pow(1 + this.bias(), this.payoff(stats));
}

/**
 * Utility function: return a sample from the exponential 
 * distribution with the given rate for inter-event timing
 */
function exponential(rate) {
    return -1 * Math.log(Math.random()) / rate;
}

/**
 * Set or get the value of the timers, for public use
 */
Cell.prototype.division = function(f) {
    if (f) {
	this.prototype._division = f
	return this;
    } else {
	return this._division();
    }
}
Cell.prototype.division.call(Cell, function () { return exponential(0.0001); });

Cell.prototype.production = function(f) {
    if (f) {
	this.prototype._production = f
	return this;
    } else {
	return this._production();
    }
}
Cell.prototype.production.call(Cell, function () { return 1/0.001; });

Cell.prototype.death = function(f) {
    if (f) {
	this.prototype._death = f;
	return this;
    } else {
	return this._death();
    }
}
Cell.prototype.death.call(Cell, function () { return exponential(0.0001); });

/**
 * Functions to emit events according to the various timers.
 * Division is a Poisson process.
 */
Cell.prototype.division_timer = function () {
    var emitter = function(cell) {
	if (!cell.alive) return;
	cell.emit("divide");
	cell._division_timer = 
	    setTimeout(emitter, cell._division(), cell);
    }
    return setTimeout(emitter, this._division(), this);
}

/**
 * Food production happens regularly. The amount (per unit time)
 * is passed to listeners on the "food" event. Cheaters produce 0.
 * A second argument, an array of nodes through which this message
 * has been passed is provided to permit loop detection as messages
 * are propagated around.
 */
Cell.prototype.production_timer = function () {
    var emitter = function(cell) {
	if (!cell.alive) return;
	var interval = cell._production();
	var amount = 1/interval;
	if (cell.kind == "cheat")
	    amount = 0;
	cell.emit("food", amount, []);
	cell._production_timer =
	    setTimeout(emitter, 1/interval, cell);
    }
    return setTimeout(emitter, 1/this._production(), this);
}

/**
 * Death is exponentially distributed and only happens once.
 */
Cell.prototype.death_timer = function () {
    var emitter = function(cell) {
	if (!cell.alive) return;
	cell.die();
	cell.emit("die");
    }
    return setTimeout(emitter, this._death(), this);
}

Cell.prototype.start_timers = function () {
    this._division_timer = this.division_timer();
    this._production_timer = this.production_timer();
    this._death_timer = this.death_timer();
}

Cell.prototype.stop_timers = function () {
    if (this._division_timer) {
	clearTimeout(this._division_timer);
	this._division_timer = null;
    }
    if (this._production_timer) {
	clearTimeout(this._production_timer);
	this._production_timer = null;
    }
    if (this._death_timer) {
	clearTimeout(this._death_timer);
	this._death_timer = null;
    }
}

/**
 * Cause the cell to die, which basically means cancelling
 * all of the timers.
 */
Cell.prototype.die = function () {
    this.alive = false;
    this.stop_timers();
}

/**
 * Get or set the neighbours of the cell
 */
Cell.prototype._neighbours = function () { return []; }
Cell.prototype.neighbours = function(f) {
    if (f) {
	Cell.prototype._neighbours = f;
	return this;
    } else {
	return this._neighbours();
    }
}

// nodejs housekeeping
module.exports = Cell;

// Local Variables:
// compile-command: "make -C .."
// End:
