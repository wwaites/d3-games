var Cell = require("cell");

function setup_count_plot(sim) {
    var d3 = sim.d3;
    var m = [0, 10, 25, 10];
    var w = 250 - m[1] - m[3];
    var h = 150 - m[0] - m[2];
    var xscale = d3.scale.linear().range([0, w]);
    var yscale = d3.scale.linear().range([h, 0]);

    var line = d3.svg.line()
	.x(function (d) { return xscale(d.x); })
	.y(function (d) { return yscale(d.y); });

    var plot = d3.select("#counts")
	.append("svg")
	.attr("width", w + m[1] + m[3])
	.attr("height", h + m[0] + m[2])
	.append("svg:g");

    plot.attr("transform", "translate(" + m[3] + "," + m[0] + ")");

    var xaxis = d3.svg.axis().scale(xscale).ticks(0);
    plot.append("svg:g")
	.style("stroke", "#000")
	.style("fill", "none")
	.attr("transform", "translate(0," + h + ")")
	.call(xaxis);

    var cheaters = plot.append("path")
	.style("stroke", sim.colours["cheat"])
	.style("stroke-width", 1)
	.style("fill", "none");
    d3.select("#counts_d").style("color", sim.colours["cheat"]);

    var cooperators = plot.append("path")
	.style("stroke", sim.colours["coop"])
	.style("stroke-width", 1)
	.style("fill", "none");
    d3.select("#counts_c").style("color", sim.colours["coop"]);

    var total = plot.append("path")
	.style("stroke", "blue")
	.style("stroke-width", 1)
	.style("fill", "none");
    d3.select("#counts_n").style("color", "blue");

    var counts = [];
    var last_count;

    var update_counts = function(sim, now) {
	var coop = 0;
	var cheat = 0;
	var total = sim.population.length;
	for (var i=0; i<sim.population.length; i++) {
	    if(sim.population[i].kind == "coop") coop += 1;
	    else cheat += 1;
	}
	last_count = {
	    time: now, 
	    coop: coop,
	    cheat: cheat,
	    total: total
	};
	counts.push(last_count);
    }

    update_counts(sim, 0);

    var update = function (sim, now) {
	update_counts(sim, now);
	xscale.domain([0, now]);
	yscale.domain([0, d3.max(counts.map(function (c) { return c.total; }))]);
	cheaters.attr("d", line(counts.map(function (c) {
	    return { x: c.time, y: c.cheat };
	})));
	cooperators.attr("d", line(counts.map(function (c) {
	    return { x: c.time, y: c.coop };
	})));
	total.attr("d", line(counts.map(function (c) {
	    return { x: c.time, y: c.total };
	})));
	d3.select("#counts_c").text(last_count.coop);
	d3.select("#counts_d").text(last_count.cheat);
	d3.select("#counts_n").text(last_count.total);
    }

    return update;
}

function setup_benefit_plot(sim) {
    var d3 = sim.d3;
    var m = [0, 10, 25, 10];
    var w = 250 - m[1] - m[3];
    var h = 150 - m[0] - m[2];
    var xscale = d3.scale.linear().domain([0, 1]).range([0, w]);
    var yscale = d3.scale.linear().domain([0, 1]).range([h, 0]);

    var line = d3.svg.line()
	.x(function (d) { return xscale(d.x); })
	.y(function (d) { return yscale(d.y); })
	.interpolate("basis");

    var plot = d3.select("#benefit")
	.append("svg")
	.attr("width", w + m[1] + m[3])
	.attr("height", h + m[0] + m[2])
	.append("svg:g");

    plot.attr("transform", "translate(" + m[3] + "," + m[0] + ")");

    var xaxis = d3.svg.axis().scale(xscale).ticks(0);
    plot.append("svg:g")
	.style("stroke", "#000")
	.style("fill", "none")
	.attr("transform", "translate(0," + h + ")")
	.call(xaxis);

    var benefit = plot.append("path")
	.style("stroke", "#34cd67")
	.style("stroke-width", 1)
	.style("fill", "none");

    var update = function(sim) {
	var max_benefit = 0;
	var stats = 
	    sim.population.map(function (c) { return c.stats(); });
	var neighbours = 
	    d3.mean(stats.map(function (s) { return s.neighbours; }));
	var data = d3.range(0, 1, 0.05).map(function (x) {
	    return {
		x: x,
		y: Cell.prototype.benefit({
		    neighbours: neighbours,
		    cooperators: x * neighbours
		})
	    }
	});
	benefit.attr("d", line(data));
    }

    return update;
}

module.exports.setup_count_plot = setup_count_plot
module.exports.setup_benefit_plot = setup_benefit_plot

// Local Variables:
// compile-command: "make -C .."
// End:
