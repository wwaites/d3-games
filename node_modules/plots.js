var Cell = require("cell");

function setup_count_plot(sim) {
    var d3 = sim.d3;
    var m = [20, 20, 15, 60];
    var w = 350 - m[1] - m[3];
    var h = 150 - m[0] - m[2];
    var xscale = d3.scale.linear().range([0, w]);
    var yscale = d3.scale.linear().range([h, 0]);

    var line = d3.svg.line()
	.x(function (d) { return xscale(d.x); })
	.y(function (d) { return yscale(d.y); });

    var plot = d3.select("#counts")
	.append("svg")
	.attr("width", w + m[1] + m[3])
	.attr("height", h + m[0] + m[2])
	.append("svg:g");
    plot.append("text")
	.attr("transform", "translate(" + (w/2) + "," + (h+15) +")")
	.attr("text-anchor", "middle")
	.text("Time");
    plot.append("text")
	.attr("transform", "translate(" + (-40) + "," + (h/2) + ")" +
	      "rotate(270)")
	.attr("text-anchor", "middle")
	.text("Cell Count");

    plot.attr("transform", "translate(" + m[3] + "," + m[0] + ")");

    var xaxis = d3.svg.axis().scale(xscale).ticks(0);
    plot.append("svg:g")
	.style("stroke", "#000")
	.style("fill", "none")
	.attr("transform", "translate(0," + h + ")")
	.call(xaxis);
    var yaxis = d3.svg.axis().scale(yscale).ticks(2).orient("left");
    var yaxisg = plot.append("g")
    	.style("stroke", "#000")
	.style("fill", "none")
	.call(yaxis);

    var cheaters = plot.append("path")
	.style("stroke", sim.colours["cheat"])
	.style("stroke-width", 1)
	.style("fill", "none");
    d3.select("#counts_d").style("color", sim.colours["cheat"]);

    var cooperators = plot.append("path")
	.style("stroke", sim.colours["coop"])
	.style("stroke-width", 1)
	.style("fill", "none");
    d3.select("#counts_c").style("color", sim.colours["coop"]);

    var total = plot.append("path")
	.style("stroke", "steelblue")
	.style("stroke-width", 1)
	.style("fill", "none");
    d3.select("#counts_t").style("color", "steelblue");

    var counts = [];
    var last_count;

    var update_counts = function(sim, now) {
	var coop = 0;
	var cheat = 0;
	var total = sim.population.length;
	for (var i=0; i<sim.population.length; i++) {
	    if(sim.population[i].kind == "coop") coop += 1;
	    else cheat += 1;
	}
	last_count = {
	    time: now, 
	    coop: coop,
	    cheat: cheat,
	    total: total
	};
	counts.push(last_count);
    }

    update_counts(sim, 0);

    var update = function (sim, now) {
	update_counts(sim, now);
	xscale.domain([0, now]);
	yscale.domain([0, d3.max(counts.map(function (c) { return c.total; }))]);

	yaxis = yaxis.scale(yscale);
	yaxisg = yaxisg.call(yaxis);

	yaxisg.call(yscale);
	cheaters.attr("d", line(counts.map(function (c) {
	    return { x: c.time, y: c.cheat };
	})));
	cooperators.attr("d", line(counts.map(function (c) {
	    return { x: c.time, y: c.coop };
	})));
	total.attr("d", line(counts.map(function (c) {
	    return { x: c.time, y: c.total };
	})));
	d3.select("#counts_c").text(last_count.coop);
	d3.select("#counts_d").text(last_count.cheat);
	d3.select("#counts_t").text(last_count.total);
    }

    return update;
}

function setup_benefit_plot(sim) {
    var d3 = sim.d3;
    var m = [10, 20, 40, 60];
    var w = 350 - m[1] - m[3];
    var h = 140 - m[0] - m[2];
    var xscale = d3.scale.linear().domain([0, 1]).range([0, w]);
    var yscale = d3.scale.linear().domain([0, 1]).range([h, 0]);

    var line = d3.svg.line()
	.x(function (d) { return xscale(d.x); })
	.y(function (d) { return yscale(d.y); })
	.interpolate("basis");

    var plot = d3.select("#benefit")
	.append("svg")
	.attr("width", w + m[1] + m[3])
	.attr("height", h + m[0] + m[2])
	.append("svg:g");
    plot.append("text")
	.attr("transform", "translate(" + (w/2) + "," + (h+35) +")")
	.attr("text-anchor", "middle")
	.text("Fraction of neighbourhood cooperative");
    plot.append("text")
	.attr("transform", "translate(-40," + (h/2) + ")" +
	      "rotate(270)")
	.attr("text-anchor", "middle")
	.text("Benefit");

    plot.attr("transform", "translate(" + m[3] + "," + m[0] + ")");

    var xaxis = d3.svg.axis().scale(xscale).ticks(5);
    plot.append("svg:g")
	.style("stroke", "#000")
	.style("fill", "none")
	.attr("transform", "translate(0," + h + ")")
	.call(xaxis);
    var yaxis = d3.svg.axis().scale(yscale).ticks(2).orient("left");
    var yaxisg = plot.append("g")
    	.style("stroke", "#000")
	.style("fill", "none")
	.call(yaxis);

    var benefit = plot.append("path")
	.style("stroke", "steelblue")
	.style("stroke-width", 1)
	.style("fill", "none");

    d3.select("#counts_nd").style("color", sim.colours["cheat"]);
    d3.select("#counts_nc").style("color", sim.colours["coop"]);
    d3.select("#counts_nh").style("color", "steelblue");

    var update = function(sim) {
	var data = d3.range(0, 1, 0.05).map(function (x) {
	    return {
		x: x,
		y: Cell.prototype.benefit({
		    neighbours: 1,
		    cooperators: x
		})
	    }
	});
	benefit.attr("d", line(data));
    }

    return update;
}

function setup_fitness_plot(sim) {
    var d3 = sim.d3;
    var m = [10, 20, 40, 60];
    var w = 350 - m[1] - m[3];
    var h = 160 - m[0] - m[2];

    var xscale = d3.scale.linear().domain([0, 1]).range([0, w]);
    var yscale = d3.scale.linear().domain([0, 1]).range([h, 0]);
    var xaxis = d3.svg.axis().scale(xscale).orient("bottom");

    var plot = d3.select("#fitness")
	.append("svg")
	.attr("width", w + m[1] + m[3])
	.attr("height", h + m[0] + m[2])
	.append("g");
    plot.attr("transform", "translate(" + m[3] + "," + m[0] + ")");

    var xaxis = d3.svg.axis().scale(xscale).ticks(5);
    plot.append("g")
	.style("stroke", "#000")
	.style("fill", "none")
	.attr("transform", "translate(0," + h + ")")
	.call(xaxis);
    var yaxis = d3.svg.axis().scale(yscale).ticks(2).orient("left");
    var yaxisg = plot.append("g")
    	.style("stroke", "#000")
	.style("fill", "none")
	.call(yaxis);

    plot.append("text")
	.attr("transform", "translate(" + (w/2) + "," + (h+35) +")")
	.attr("text-anchor", "middle")
	.text("Fitness");
    plot.append("text")
	.attr("transform", "translate(" + (-40) + "," + (h/2) + ")" +
	      "rotate(270)")
	.attr("text-anchor", "middle")
	.text("Cell count");

    function update(sim) {
	var fits = sim.population.map(function (c) {
	    return { cell: c, fitness: c.fitness() / (1 + c.bias()) };
	});
	var all_fits = fits.map(function (f) { return f.fitness; });
	var coop_fits = fits
	    .filter(function (f) { return f.cell.kind == "coop"; })
	    .map(function (f) { return f.fitness; });
	var cheat_fits = fits
	    .filter(function(f) { return f.cell.kind == "cheat"; })
	    .map(function(f) { return f.fitness; });

	var max_fit = 1;
	var all_data = d3.layout.histogram().bins(20).range([0, max_fit])(all_fits);
	var coop_data = d3.layout.histogram().bins(20).range([0, max_fit])(coop_fits);
	var cheat_data = d3.layout.histogram().bins(20).range([0, max_fit])(cheat_fits);
	
	yscale = yscale.domain([0, sim.population.length]);
	yaxis = yaxis.scale(yscale);
	yaxisg = yaxisg.call(yaxis);

	var dx = xscale(d3.max(all_data, function(d) { return d.dx/3; }));

	plot.selectAll(".coop_fitness").remove();
	var coop_bar = plot.selectAll(".coop_fitness").data(coop_data);
	coop_bar.enter().append("g")
	    .attr("class", "coop_fitness")
	    .attr("transform", function(d) {
		return "translate(" + (xscale(d.x) - 1.5*dx) + "," + yscale(d.y) + ")";
	    })
	    .append("rect")
	    .attr("x", 0)
	    .attr("width", dx)
	    .attr("height", function(d) { return h - yscale(d.y); })
	    .style("fill", sim.colours["coop"])
	    .style("shape-rendering", "crispEdges");

	plot.selectAll(".cheat_fitness").remove();
	var cheat_bar = plot.selectAll(".cheat_fitness").data(cheat_data);
	cheat_bar.enter().append("g")
	    .attr("class", "cheat_fitness")
	    .attr("transform", function(d) {
		return "translate(" + (xscale(d.x) - 0.5*dx) + "," + yscale(d.y) + ")";
	    })
	    .append("rect")
	    .attr("x", 0)
	    .attr("width", dx)
	    .attr("height", function(d) { return h - yscale(d.y); })
	    .style("fill", sim.colours["cheat"])
	    .style("shape-rendering", "crispEdges");

	plot.selectAll(".all_fitness").remove();
	var all_bar = plot.selectAll(".all_fitness").data(all_data);
	all_bar.enter().append("g")
	    .attr("class", "all_fitness")
	    .attr("transform", function(d) {
		return "translate(" + (xscale(d.x) + 0.5*dx) + "," + yscale(d.y) + ")";
	    })
	    .append("rect")
	    .attr("x", 0)
	    .attr("width", dx)
	    .attr("height", function(d) { return h - yscale(d.y); })
	    .style("fill", "steelblue")
	    .style("shape-rendering", "crispEdges");

    }
    return update;
}

module.exports.setup_count_plot = setup_count_plot
module.exports.setup_benefit_plot = setup_benefit_plot
module.exports.setup_fitness_plot = setup_fitness_plot

// Local Variables:
// compile-command: "make -C .."
// End:
