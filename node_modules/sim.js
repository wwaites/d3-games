var events = require("events");

function Sim(Cell, div, window) {
    this.C = Cell;

    // if we are running under jsdom instead of in the browser
    // then window is explicitly passed to us. otherwise in
    // the browser we need to get a handle for d3js using 
    // require.
    if(window)
	this.d3 = window.d3;
    else
	this.d3 = require("d3.v3");

    this.running = false;
    this.population = [];
    this.mutation(function () { return 0.01; });

    this.voronoi = this.d3.geom.voronoi()
	.x(function(cell) { return cell.x; })
	.y(function(cell) { return cell.y; });

    // javascript is so stupid. fix the this reference.
    var self = this;
    this.force = this.d3.layout.force()
	.charge(-250)
	.friction(0.1)
	.size([this.w(), this.h()])
	.on("tick", function() { self.relax.call(self); });

    this.svg = this.d3.select(div)
	.append("svg")
	.attr("width", this.w())
	.attr("height", this.h());

    this.circle = this.svg.selectAll("circle");
    this.path = this.svg.selectAll("path");
    this.link = this.svg.selectAll("line");

    events.EventEmitter.call(this);
}

Sim.prototype = Object.create(events.EventEmitter.prototype);
Sim.prototype.constructor = Sim;

Sim.prototype.mutation = function(f) {
    if (f) {
	this._mutation = f;
	return this;
    } else {
	return this._mutation();
    }
}

Sim.prototype.divide = function(cell) {
    if (Math.random() > cell.fitness()/(1 + cell.bias())) {
	return;
    }

    // possibly mutate
    var kind = cell.kind;
    if (Math.random() < this.mutation()) {
	if (cell.kind == "coop") kind = "cheat";
	else kind = "coop";
    }

    // divide in some random direction
    angle = Math.random() * 360;
    var child = this.newCell(kind);
    child.x = cell.x + Math.cos(angle)/this.w();
    child.y = cell.y + Math.sin(angle)/this.h();

    // add to the list of cells and redo the layout
    this.population.push(child);
    child.start_timers();
    this.force.nodes(this.population).start()
}

Sim.prototype.eat = function(cell, amount, path) {
    // if the food has travelled too far, it is probably
    // stale and mouldy and we don't want to eat it.
    if (path.length > 5) {
	return;
    }

    // have we seen this food before? boring.
    for (var i=0; i<path.length; i++) {
	if (path[i] == cell.id)
	    return;
    }

    // add ourselves to the path because we don't want to
    // chew the same food twice
    path.push(cell.id);

    var now = new Date().getTime();

    var window = 10 * cell.production();
    // expire old food
    for (var i in cell.food) {
	if (now - cell.food[i].time > window) {
	    delete cell[i];
	}
    }

    // record the amount
    cell.food[path[0]] = { amount: amount, time: now };

    // send to neighbours
    var neighbours = this.neighbours(cell);
    for (var i=0; i<neighbours.length; i++) {
	neighbours[i].emit("food", amount, path);
    }
}

Sim.prototype.die = function(cell) {
    this.population = this.population.filter(function (e) { return e.id != cell.id; });
    this.force.nodes(this.population).start()
}

Sim.prototype.w = function () { return 500; }
Sim.prototype.h = function () { return 500; }
Sim.prototype.charge = function (c) {
    this.force.charge(c);
    return this;
}
Sim.prototype.friction = function (f) {
    this.force.friction(f);
    return this;
}
Sim.prototype.size = function(s) {
    this.w = function () { return s[0]; }
    this.h = function () { return s[1]; }
    this.force.size(s);
    this.svg.attr("width", this.w());
    this.svg.attr("height", this.h());
}

Sim.prototype.popSize = function () { return 3; }
Sim.prototype.resetPopulation = function() {
    var self = this;
    if(this.population) {
	for (var i=0; i<this.population.length; i++) {
	    this.population[i].die();
	}
    }
    this.population = this.d3.range(this.popSize()).map(function(i) {
	var cell = self.newCell();
	cell.x = Math.random() * self.w();
	cell.y = Math.random() * self.h();
	return cell;
    });
}

Sim.prototype.newCell = function(kind) {
    var cell = new this.C(kind);
    self = this;
    cell.neighbours(function () { return self.neighbours.call(self, this); })
	.on("divide", function() { self.divide.call(self, this); })
	.on("food", function(amount, path) { 
	    self.eat.call(self, this, amount, path);
	})
	.on("die", function() { self.die.call(self, this); });
    return cell;
}

Sim.prototype.start = function() {
    this.resetPopulation();
    this.resume();
}

Sim.prototype.pause = function() {
    this.running = false;
    this.stop_timers();
    for (var i=0; i<this.population.length; i++) {
	var cell = this.population[i];
	cell.stop_timers();
    }
}

Sim.prototype.resume = function() {
    for (var i=0; i<this.population.length; i++) {
	var cell = this.population[i];
	cell.start_timers();
    }
    this.start_timers();
    this.force.nodes(this.population);
    this.running = true;
    this.force.start();
}

Sim.prototype.relax = function () {
    self = this;
    this.path = this.path.data(this.voronoi(this.population));
    this.path.enter().append("path")
    this.path.attr("d", function (d) { return "M" + d.join("L") + "Z"; })
	.style("fill", function(d) { return self.colours[d.point.kind]; })
	.style("stroke-width", 1);
    this.path.exit().remove();

/*
    this.circle = this.circle.data(this.population, function(d) { return d.id; });
    this.circle.enter().append("circle")
	.attr("r", 1)
	.attr("id", function(d) { return "c" + d.id; })
	.attr("cx", function(d) { console.log(d); return d.x; })
	.attr("cy", function(d) { return d.y; });
    this.circle.exit().remove();

    this.link = this.link.data(this.voronoi.links(this.population));
    this.link.enter().append("line");
    this.link
	.style("stroke-width", 10)
	.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
    this.link.exit().remove();
*/

    if(!this.running) this.force.stop();
}

Sim.prototype.neighbours = function(cell) {
    n = [];
    /* this is not especially efficient... */
    links = this.voronoi.links(this.population);
    for (var i=0; i<links.length; i++) {
	if (links[i].source.id == cell.id) {
	    n.push(links[i].target);
	} else if (links[i].target.id == cell.id) {
	    n.push(links[i].source);
	}
    }
    return n;
}

Sim.prototype.colours = { 
    cheat: "#c84554",
    coop: "#00c884"
};

Sim.prototype.stepsize = 1000;
Sim.prototype.step_timer = function () {
    var emitter = function(sim) {
	sim.emit("step");
    }
    return setInterval(emitter, this.stepsize, this);
}

Sim.prototype.start_timers = function () {
    this._step_timer = this.step_timer();
}

Sim.prototype.stop_timers = function () {
    if (this._step_timer) {
	clearInterval(this._step_timer);
	this._step_timer = null;
    }
}

module.exports = Sim;

// Local Variables:
// compile-command: "make -C .."
// End:
